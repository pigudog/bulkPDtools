-   

    ```         
    ("PCOS" OR "polycystic ovary syndrome" OR "Stein-Leventhal syndrome" OR "sclerocystic ovarian degeneration" OR "sclerocystic ovaries" OR "sclerocystic ovary syndrome") AND ("granulosa cells" OR "GC" OR "cumulus cells" OR "granulosa cumulus cells") AND ("human" OR "homo sapiens")
    ```

-   **ranseq**

    -   **GSE138518**

        -   Illumina NovaSeq 6000 (Homo sapiens)

        -   3vs3

        -   RNA sequencing in ovarian granulosa cells of PCOS patients and normal people

    -   **GSE155489**

        -   HiSeq X Ten (Homo sapiens)

        -   4vs4

        -   GCs from three PCOS patients and compared them with age-matched, women without PCOS, and performed RNA sequencing analysis to explore the transcriptional characteristics of their oocytes and GCs

    -   GSE173160 - 不行是lncRna

    -   **GSE193123**

        -   Illumina NovaSeq 6000 (Homo sapiens)

        -   3vs3

        -   Granulosa cells collected from two individuals were pooled as one sample for RNA-sequencing, and there was three samples in control and PCOS group.

    -   **GSE168404**

        -   Illumina HiSeq 2500 (Homo sapiens)

        -   5vs5

        -   Granulosa cells of five women with PCOS and five age/body mass index (BMI)-matched control subjects

# Merge

Run the following code to remove batch

```{r}
# name of merged file
mergeFile="./data/merge_count_deg_preremove.txt" 
# name of normalized file
normalizeFile="./data/merge.normalize.txt"      #
# get the file 
files=c('GSE138518.txt','GSE155489.txt',"GSE193123.txt")       #the "GSE168404.txt" used as a test set
# acquisition of intersection gene
length(files)
```

```{r}
library(data.table)

dir = "data/"
geneList=list()
for(i in 1:length(files)){
  fileName=paste0(dir,files[i])
  # fread() for reading data into a regular data frame
  rt=fread(fileName,data.table = F)
  # unlist() will convert the result of `strsplit` into a flattened vector
  header=unlist(strsplit(fileName, "\\.|\\-"))
  geneList[[header[1]]]=as.vector(rt[,1])
}
# The result will be a vector containing the common genes that are present in all the lists within geneList.
intersectGenes=Reduce(intersect, geneList)
# show the length
length(intersectGenes)

```

We get count, so instead of log2, we're going to go through DEseq2 for search DEG genes

```{r}
library(limma)
#数据合并
allTab=data.frame()
batchType=c()
for(i in 1:length(files)){
  fileName=files[i]
  header=unlist(strsplit(fileName, "\\.|\\-"))
  #读取输入文件，并对输入文件进行整理
  rt=fread(paste0(dir,fileName),data.table = F)
  rt=as.matrix(rt)
  rownames(rt)=rt[,1]
  exp=rt[,2:ncol(rt)]
  dimnames=list(rownames(exp),colnames(exp))
  data=matrix(as.numeric(as.matrix(exp)), nrow=nrow(exp), dimnames=dimnames)
  # avereps in limma package can average the expression values of the same genes.
  rt=avereps(data)
  colnames(rt)=paste0(header[1], "_", colnames(rt))
  # log or not
  # rt[rt<0]=0
  # rt=log2(rt+1)}
  # rt=normalizeBetweenArrays(rt)
  # 数据合并
  if(i==1){
    allTab=rt[intersectGenes,]
  }else{
    allTab=cbind(allTab, rt[intersectGenes,])
  }
  batchType=c(batchType, rep(header[1],ncol(rt)))
}

allTabOut=rbind(geneNames=colnames(allTab), allTab)
write.table(allTabOut, file=mergeFile, sep="\t", quote=F, col.names=F)
```

have a view of this mergeFile

```{r}
raw_data <- read.table("data/merge_count_deg_preremove.txt",header = T)
rownames(raw_data) <- raw_data$geneNames
raw_data<- raw_data[,-1]
dim(raw_data)
```

```{r}
boxplot(raw_data)
```

check the batch type

```{r}
table(batchType)
batchType
```

```{r}
# the type of this allTab is a large matrix
rt <- allTab
rt <- as.data.frame(rt)
rt[1:5,1:5]
```

```{r}
group_list1=c(rep('CT',3),rep('PC',3))
group_list2=c(rep('CT',4),rep('PC',4))
group_list3=c(rep('CT',3),rep('PC',3))
group_list=c(group_list1,group_list2,group_list3)
group_list=factor(group_list,levels=c('CT','PC'))

# a = grep('GSE138518',colnames(rt))
# b = grep('GSE155489',colnames(rt))
# c = grep('GSE193123',colnames(rt))
# 
# exprSet=rt[,c(a,b,c)]
exprSet <- rt
```

```{r}
group_list
table(group_list)
```

```{r}
# condition is the grouping we need for our comparison, and type is our batch
coldata <- data.frame(condition = group_list, type = batchType)
coldata
```
```{r}
rownames(coldata) <- colnames(exprSet)
coldata
```

```{r}
library(DESeq2)
dds <- DESeqDataSetFromMatrix(countData = exprSet,
                              colData = coldata,
                              design = ~ type+condition)
dds <- DESeq(dds)
```

```{r}
resultsNames(dds)
```
```{r}
res <- results(dds, name="condition_PC_vs_CT")
summary(res)
```
```{r}
DEG <- as.data.frame(res)
DEG <- DEG[order(DEG$pvalue),] 
DEG = na.omit(DEG)
head(DEG)
```
```{r}
save(DEG,file = "data/DESeq2_raw.Rdata")
write.table(DEG,row.names=TRUE,col.names=TRUE,sep=",","data/DESeq2_PCvsCT_raw.csv")
```

# pca plot

```{r}
library(ggplot2)
vsd <- vst(dds, blind=FALSE)
# the pca data contain details of pca information
pcaData <- plotPCA(vsd, intgroup=c("condition", "type"), returnData=TRUE)
# calculates the percentage of variance explained by each principal component in a PCA analysis stored in the pcaData object. 
percentVar <- round(100 * attr(pcaData, "percentVar"))
color = c("#00AFBB","#FC4E07","#e6b707","#2874C5","#f87669","#868686","#92C5DE","#F4A582","#66C2A5","#FC8D62","#8DA0CB","#E78AC3","#A6D854","#FFD92F","#E5C494","#B3B3B3","#999999")
# the condition represent the disease type: PC and CT
# the type represent the sample name: gsexxxx
# Both scale_color_manual and scale_fill_manual are used to manually set color maps, but they apply to different graphic properties. The former is used to adjust the border color of the element, line color, etc., and the latter is used to set the fill color, such as the column color of the bar chart or the fill color below the area chart.
ggplot(pcaData, aes(PC1, PC2, color=condition, shape = type)) +
  scale_color_manual(values = color[1:nlevels(group_list)])+
  # scale_fill_manual(values = color[1:nlevels(group_list)])+
  geom_point(size=5)+ 
  # xlim(-80, 80) +
  # ylim(-60, 60) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance"))
  # geom_text(aes(label=name),vjust=2)
```
```{r}
assay(vsd) <- limma::removeBatchEffect(assay(vsd), vsd$type)
pcaData <- plotPCA(vsd, intgroup=c("condition", "type"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=condition, shape = type)) +
  scale_color_manual(values = color[1:nlevels(group_list)])+
  geom_point(size=3) 
  # geom_text(aes(label=name),vjust=2)
```
```{r}
library(PDtools)
# the tinyarray is package
vsd <- vst(dds, blind=FALSE)
dat <- assay(vsd)
Group <- factor(coldata$type,levels=c('GSE138518','GSE155489','GSE193123'))
# the dat has been log2
# alpha = 0.3: This sets the transparency level (alpha) of the ellipses. A value of 0.3 means the ellipses will be somewhat transparent.
# linetype = 2: This sets the line type of the ellipse's border. A value of 2 specifies a dashed line type.
pca.plot = draw_pca(dat,Group)+
  scale_color_manual(values = color[1:3])
      # stat_ellipse(aes(color = Group,fill = Group),
      #              geom = "polygon",
      #              alpha = 0.3,
      #              linetype = 2)
pca.plot
```

```{r}
library(PDtools)
assay(vsd) <- limma::removeBatchEffect(assay(vsd), vsd$type)
# the tinyarray is package
dat <- assay(vsd)
Group <- factor(coldata$type,levels=c('GSE138518','GSE155489','GSE193123'))
# the dat has been log2
# alpha = 0.3: This sets the transparency level (alpha) of the ellipses. A value of 0.3 means the ellipses will be somewhat transparent.
# linetype = 2: This sets the line type of the ellipse's border. A value of 2 specifies a dashed line type.
pca.plot = draw_pca(dat,Group)
      # stat_ellipse(aes(color = Group,fill = Group),
      #              geom = "polygon",
      #              alpha = 0.3,
      #              linetype = 2)
pca.plot
```
# pheatmap
```{r}
group_list1=c(rep('CT',3),rep('PC',3))
group_list2=c(rep('CT',4),rep('PC',4))
group_list3=c(rep('CT',3),rep('PC',3))
group_list=c(group_list1,group_list2,group_list3)
group_list=factor(group_list,levels=c('CT','PC'))
dat <- limma::removeBatchEffect(exprSet, vsd$type)
dat1 <- exprSet[,group_list=="CT"]

dat2 <- exprSet[,group_list=="PC"]

dat <- cbind(dat1,dat2)

library(limma)
dat <- log2(dat+1)
group_list = factor(c(rep("CT",10),rep("PC",10)),levels=c('CT','PC'))
# cg=names(tail(sort(apply(dat,1,sd)),1000))#apply按行（'1'是按行取，'2'是按列取）取每一行的方差，从小到大排序，取最大的1000个
```


```{r}
###差异基因名称提取
DEG_genes <- DEG[DEG$padj<0.01&abs(DEG$log2FoldChange)>1.5,]
DEG_sorted <- DEG_genes[order(DEG_genes$log2FoldChange,decreasing = T), ]
tem1 <- head(rownames(DEG_sorted),50)
tem2 <- tail(rownames(DEG_sorted),50)
# 我们需要降序
library(pheatmap)
n=t(scale(t(dat[c(tem1,tem2),]))) # 'scale'可以对log-ratio数值进行归一化
# cg=names(tail(sort(apply(dat,1,sd)),1000))#apply按行（'1'是按行取，'2'是按列取）取每一行的方差，从小到大排序，取最大的1000个
# n=t(scale(t(dat[cg,])))
# n[n>2]=2 
# n[n< -2]= -2
# pheatmap(n,show_colnames =F,show_rownames = F)
ac=data.frame(g=group_list)
rownames(ac)=colnames(n) #把ac的行名给到n的列名，即对每一个探针标记上分组信息（是'noTNBC'还是'TNBC'）
## 可以看到TNBC具有一定的异质性，拿它来区分乳腺癌亚型指导临床治疗还是略显粗糙。
# pheatmap(n,show_colnames =F,show_rownames = F,
#          annotation_col=ac,filename = './Figure1//heatmap_top1000_sd.png')
pheatmap(n,show_colnames =F,show_rownames = F,annotation_col=ac,cluster_cols = F)
```
this way the pheatmap is not good enough
```{r}
DEG_gene_expr <- dat[c(tem1,tem2),]
# DEG_gene_expr <- t(scale(t(DEG_gene_expr)))
# png(paste0(job,'3mVS9M_DEG_pheatmap.png'),width =1024,height =1024)
pheatmap(DEG_gene_expr,color=colorRampPalette(c("#2874C5","white","#FC4E07"))(100),
         scale="row",
         border_color=NA,
         fontsize=10,
         show_rownames=T,
         annotation_col=ac)
```

